#!/usr/bin/env perl

#PODNAME: zxtm

use strict;
use warnings;

local $| = 1;

use FindBin;
use lib "$FindBin::Bin/../lib";

use JSON;

use Net::ZXTM;
use Number::Format qw(:subs);
use Time::Duration;
use URI::Escape ();
use Crypt::OpenSSL::X509;

use Data::Dumper;

use Template;

my $tt = Template->new({
               INCLUDE_PATH => "$FindBin::Bin/../tt",  # or list ref
               INTERPOLATE  => 1,               # expand "$var" in plain text
               POST_CHOMP   => 1,               # cleanup whitespace
               EVAL_PERL    => 1,               # evaluate Perl code blocks
           });

use RRD::Simple ();

#$RRD::Simple::DEBUG=1;
#

my $invocation = join " ", ( '$>', $0, @ARGV);
print "$invocation\n";

my $rrd = RRD::Simple->new( default_dstype => "COUNTER", );

my %rrd_default = (
    ssl_cipher_encrypts => "COUNTER",
    ssl_cipher_decrypts => "COUNTER",
    total_conn          => "COUNTER",
    total_requests      => "COUNTER",
    sys_cpu_busy_percen => "GAUGE",
    sys_cpu_idle_percen => "GAUGE",
    hourly_peak_bytes_i => "GAUGE",
    hourly_peak_bytes_o => "GAUGE",
    
);

#substr( $str, 0, 3 );

my %zxtms;
foreach my $url (@ARGV) {
    my $uri  = URI->new($url);
    my $host = $uri->host;

    my $rrdfile = "rrd/global-$host.rrd";
    $rrd->create( $rrdfile, %rrd_default ) if !-f $rrdfile;

    my $zxtm = Net::ZXTM->new( $url, $ENV{ZXTM_USER}, $ENV{ZXTM_PASS} );
    
    #Remember each TM by its url for now
    #XXX: Cheat
    my $web_url = URI->new($uri);
    $web_url->port(9090);
    $zxtms{$url} = {
      url => $web_url,
    };

    my $resp = $zxtm->call("/status");

    my %zxtm;

    foreach my $zxtm (@$resp) {
        next if ( 'local_tm' eq $zxtm->{name} );
        $zxtm{ $zxtm->{name} } = 1;
    }
    my $total_zxtm = scalar keys %zxtm;

    print "Info for $total_zxtm nodes cluster : " . $url . "\n";

    my %total_stats;

    foreach my $tm ( sort keys %zxtm ) {
        my $info    = $zxtm->call("/status/$tm/information");
        my $version = $info->{information}{tm_version};

        my $global_stat =
          $zxtm->call("/status/$tm/statistics/globals")->{statistics};

        print " - $tm (v$version)\n";

        $rrd->create( "rrd/$tm.rrd", %rrd_default ) if !-f "rrd/$tm.rrd";
        $rrd->update( "rrd/$tm.rrd", %$global_stat );
        foreach my $stat ( sort keys %$global_stat ) {
            $total_stats{$stat} += $global_stat->{$stat};
            output_stat( $stat, $global_stat->{$stat} );
        }
    }

    print " - Cluster Total\n";
    foreach my $stat ( sort keys %total_stats ) {

        #Compute an average
        if ( $stat =~ /^sys_cpu/ ) {
            $total_stats{$stat} = int( $total_stats{$stat} / $total_zxtm );
        }

        output_stat( $stat, $total_stats{$stat} );
    }

    $rrd->update( $rrdfile, %total_stats );

    $rrd->graph(
        $rrdfile,
        basename => "global-$host-hourly_peak_bytes",
        sources  => [
            qw(
              hourly_peak_bytes_i
              hourly_peak_bytes_o
              )
        ],
    );
    $rrd->graph(
        $rrdfile,
        basename => "global-$host-hourly_cpu",
        sources  => [
            qw(
              sys_cpu_busy_percen
              sys_cpu_idle_percen
              )
        ],
    );
    $rrd->graph(
        $rrdfile,
        basename => "global-$host-encryption",
        sources  => [
            qw(
              ssl_cipher_encrypts
              ssl_cipher_decrypts
              )
        ],
    );
    
    $rrd->graph(
        $rrdfile,
        basename => "global-$host-total_conn_rec",
        sources  => [
            qw(
              total_conn
              total_requests
              )
        ],
    );

    $zxtms{$url}{ssl}   = check_ssl($zxtm);
    $zxtms{$url}{pools} = check_pools($zxtm);
}

my $tt_data = {
  when => time,
  invocation => $invocation, 
  zxtms => \%zxtms,
};

use Storable;
store $tt_data, 'zxtms.storable';

print STDERR "Writing out JSON\n";
open (my $jdump, ">", "index.json");
print $jdump encode_json($tt_data);
close($jdump);

$tt->process('index.tt', $tt_data, 'index.html')
               || die $tt->error(), "\n";

sub check_ssl {
    my $zxtm = shift;
    print "** Checking SSL\n";

    my $certs = $zxtm->call("/config/active/ssl/server_keys");

    my %certs;
    foreach my $cert (@$certs) {
        my $name = $cert->{name};
        my $info = $zxtm->call("/config/active/ssl/server_keys/$name");

        $certs{$name}{note} = $info->{properties}{basic}{note};

        my $x509 = Crypt::OpenSSL::X509->new_from_string(
            $info->{properties}{basic}{public} );

        $certs{$name}{not_before} = $x509->notBefore();
        $certs{$name}{not_after}  = $x509->notAfter();
        $certs{$name}{subject}    = $x509->subject();
        $certs{$name}{valid_now}  = !$x509->checkend(0);
        $certs{$name}{valid_soon} = !$x509->checkend( 60 * 60 * 24 * 30 );
        
	my $status = "ok";
        if ( !$certs{$name}{valid_now} or !$certs{$name}{valid_soon} ) {
            
            if ( !$certs{$name}{valid_soon} ) {
                $status = "expiring";
            }
            if ( !$certs{$name}{valid_now} ) {
                $status = "expired";
            }
            print " * [$status] $name Expires on $certs{$name}{not_after}\n";
        }
	
	$certs{$name}{status} = $status;
	
    }
    
    return \%certs;
}

sub check_pools {
    my $zxtm = shift;

    print "** Checking pools\n";

    my $pools = $zxtm->call("/config/active/pools");

    my %pools;
    foreach my $pool (@$pools) {
        my $name = $pool->{name};

        $pools{$name}{info} = $zxtm->call("/config/active/pools/$name");
        $pools{$name}{note} = URI::Escape::uri_unescape(
            $pools{$name}{info}{properties}{basic}{note} );
        $pools{$name}{nodes} = {};

        my $node_count =
          @{ $pools{$name}{info}{properties}{basic}{nodes_table} };
        my $interesting;

        foreach
          my $node ( @{ $pools{$name}{info}{properties}{basic}{nodes_table} } )
        {
            my $state = $node->{state} || '*no-state*';
            $interesting++ if $state ne 'active';
        }

        if ($interesting) {
	    $pools{$name}{interesting} = 1;
            print " Pool $name ($node_count nodes):\n";
            print "  * Note: $pools{$name}{note}\n" if $pools{$name}{note};

            foreach my $node (
                @{ $pools{$name}{info}{properties}{basic}{nodes_table} } )
            {
                my $name = $node->{node};

                if ( $name =~ /(\d+\.\d+\.\d+\.\d+):(\d+)/ ) {
                    my $port = $2;
                    my $ip   = $1;

                    use Socket;
                    my $fqdn = gethostbyaddr( inet_aton($ip), AF_INET );
                    if ($fqdn) {
                        $name = "$fqdn($ip):$port";
                    }

                }

                my $state = $node->{state} || '*no-state*';
                print "  + [$state] $name\n";
            }

        }
    }
    
    return \%pools;
}

my %pretty_names = (
    hourly_peak_bytes_in        => "Hourly Peak Bytes In",
    hourly_peak_bytes_out       => "Hourly Peak Bytes Out",
    hourly_peak_requests        => "Hourly Peak Requests",
    hourly_peak_ssl_connections => "Hourly Peak SSL Connections",
    sys_cpu_busy                => "CPU Busy",
    sys_cpu_idle                => "CPU Idle",
    sys_cpu_system_busy         => "CPU Syatem Busy",
    sys_cpu_user_busy           => "CPU User Busy",
    sys_mem_buffered            => "Memory Buffered",
    sys_mem_free                => "Memory Free",
    sys_mem_in_use              => "Memory Used",
    sys_mem_swap_total          => "Swap Total",
    sys_mem_swapped             => "Swap Used",
    sys_mem_total               => "Memory Total",
);

sub output_stat {
    my ( $stat, $stat_value ) = @_;

    my $val;

    if ( $stat =~ /peak/ ) {
        $val = format_bytes($stat_value);

        if ( $stat =~ /_per_second/ ) {
            $stat =~ s/_per_second//;
            $val .= "/s";
        }
    }

    if ( $stat =~ /^sys_cpu/ ) {
        $val = $stat_value;

        if ( $stat =~ /_percent$/ ) {
            $stat =~ s/_percent$//;
            $val .= " %";
        }
    }

    if ( $stat =~ /^sys_mem/ ) {
        $val = format_bytes( $stat_value * 1024 * 1024 );
    }

    if ( $stat =~ /^ssl_cipher_(de|en)crypts/ ) {
        $val = $stat_value;
    }

    if ($val) {
        my $pretty = $pretty_names{$stat} || $stat;
        print "    - $pretty: $val\n";
    }
}



__END__
