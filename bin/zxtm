#!/usr/bin/env perl

#PODNAME: zxtm

use strict;
use warnings;

local $| = 1;

use FindBin;
use lib "$FindBin::Bin/../lib";

use JSON;

use Net::ZXTM;
use Number::Format qw(:subs);
use Time::Duration;
use URI::Escape ();
use Crypt::OpenSSL::X509;

use Data::Dumper;

use Template;

my $tt = Template->new({
               INCLUDE_PATH => "$FindBin::Bin/../tt",  # or list ref
               INTERPOLATE  => 1,               # expand "$var" in plain text
               TRIM         => 1,               # cleanup whitespace
               EVAL_PERL    => 1,               # evaluate Perl code blocks
           });

use RRD::Simple ();

$RRD::Simple::DEBUG=1;
#

my $invocation = join " ", ( '$>', $0, @ARGV);
print "$invocation\n";

my $rrd = RRD::Simple->new(
  on_missing_ds => 'die',
);

#sub record_stats {
#  my ($tm, $stats) = @_;
#  
#  my $rrd_file = "rrd/$tm.rrd";
#  
#  $rrd->create( $rrd_file, %rrd_default) if !-f $rrd_file;
#  
#  my %rrd_stats = rrd_truncate_hash(%$stats);
#  
#  #Limit stats to known ones
#  # %rrd_stats = map { $_ => $rrd_stats{$_} } qw/hourly_peak_bytes_i hourly_peak_bytes_o/;
#  
#  foreach my $k (sort keys %rrd_stats) {
#    print STDERR "RRD:$tm:$k:$rrd_stats{$k}\n";
#  }
#
#  $rrd->update($rrd_file, %rrd_stats);
#  
#  local $RRD::Simple::DEBUG = 0;
#  
#  $rrd->graph(
#    $rrd_file,
#    destination => "graphs/",
#    basename => "${tm}_hourly_peak_bytes",
#    extended_legend => 1,
#    sources => [qw(
#      hourly_peak_bytes_i
#      hourly_peak_bytes_o
#    )],
#    
#    #Plot averages
#    "VDEF:hourly_peak_bytes_oAVERAGE=hourly_peak_bytes_o,AVERAGE" => "",
#    "HRULE:hourly_peak_bytes_oAVERAGE#00ff77:AverageOut" => "",
#    "VDEF:hourly_peak_bytes_iAVERAGE=hourly_peak_bytes_i,AVERAGE" => "",
#    "HRULE:hourly_peak_bytes_iAVERAGE#00ff77:AverageIn" => "",
#  );
#  
#  $rrd->graph(
#    $rrd_file,
#    title => "CPU Utilization",
#    destination => "graphs/",
#    basename => "${tm}_hourly_cpu",
#    extended_legend => 1,
#    sources => [qw(
#      sys_cpu_idle_percen
#      sys_cpu_system_busy
#      sys_cpu_user_busy_p
#    )],
#    source_labels => [
#      "CPU Idle %",
#      "CPU System Busy %",
#      "CPU User Busy %",
#    ],
#  );
#
#  $rrd->graph(
#    $rrd_file,
#    title => "SSL Operations",
#    destination => "graphs/",
#    basename => "${tm}_encryption",
#    extended_legend => 1,
#    sources => [qw(
#      ssl_cipher_encrypts
#      ssl_cipher_decrypts
#    )],
#  );
#  
#  $rrd->graph(
#    $rrd_file,
#    title => "Total Usage",
#    destination => "graphs/",
#    basename => "${tm}_usage",
#    extended_legend => 1,
#    sources => [qw(
#      total_conn
#      total_requests
#    )],
#  );
#}

my %zxtms;
foreach my $url (@ARGV) {
    my $uri  = URI->new($url);
    my $host = $uri->host;

    my $zxtm = Net::ZXTM->new( $url, $ENV{ZXTM_USER}, $ENV{ZXTM_PASS} );
    
    #Remember each TM by its url for now
    #XXX: Cheat
    my $web_url = URI->new($uri);
    $web_url->port(9090);
    $zxtms{$url} = {
      url => $web_url->as_string(),
    };

    my $resp = $zxtm->call("/status");

    my %zxtm;

    foreach my $zxtm (@$resp) {
        next if ( 'local_tm' eq $zxtm->{name} );
        $zxtm{ $zxtm->{name} } = 1;
    }
    my $total_zxtm = scalar keys %zxtm;

    print "Info for $total_zxtm nodes cluster : " . $url . "\n";

#    my %total_stats;
#
#    foreach my $tm ( sort keys %zxtm ) {
#        my $info    = $zxtm->call("/status/$tm/information");
#        my $version = $info->{information}{tm_version};
#
#        my $global_stat =
#          $zxtm->call("/status/$tm/statistics/globals")->{statistics};
#
#        print " - $tm (v$version)\n";
#	
#	#record_stats($tm, $global_stat);
#	
#        foreach my $stat ( sort keys %$global_stat ) {
#            $total_stats{$stat} += $global_stat->{$stat};
#            output_stat( $stat, $global_stat->{$stat} );
#        }
#    }
#
#    #record_stats("global-$host", \%total_stats);
#
#    print " - Cluster Total\n";
#    foreach my $stat ( sort keys %total_stats ) {
#
#        #Compute an average
#        if ( $stat =~ /^sys_cpu/ ) {
#            $total_stats{$stat} = int( $total_stats{$stat} / $total_zxtm );
#        }
#
#        output_stat( $stat, $total_stats{$stat} );
#    }
#    
    

    $zxtms{$url}{ssl}   = check_ssl($zxtm);
    $zxtms{$url}{pools} = check_pools($zxtm);
}

my $tt_data = {
  when => time,
  invocation => $invocation, 
  zxtms => \%zxtms,
};

print STDERR "Producing HTML\n";
$tt->process('index.tt', $tt_data, 'index.html')
               || die $tt->error(), "\n";

use Storable;
store $tt_data, 'index.storable';

open (my $jdump, ">", "index.json");
print $jdump encode_json($tt_data);
close($jdump);


sub check_ssl {
    my $zxtm = shift;
    print "** Checking SSL\n";

    my $certs = $zxtm->call("/config/active/ssl/server_keys");

    my %certs;
    foreach my $cert (@$certs) {
        my $name = $cert->{name};
        my $info = $zxtm->call("/config/active/ssl/server_keys/$name");

        $certs{$name}{note} = $info->{properties}{basic}{note};
	
        my $x509 = Crypt::OpenSSL::X509->new_from_string(
            $info->{properties}{basic}{public} );

        $certs{$name}{not_before} = $x509->notBefore();
        $certs{$name}{not_after}  = $x509->notAfter();
        $certs{$name}{subject}    = $x509->subject();
        $certs{$name}{valid_now}  = !$x509->checkend(0);
        $certs{$name}{valid_soon} = !$x509->checkend( 60 * 60 * 24 * 30 );
        
	my $status = "ok";
	
        if (!$certs{$name}{valid_now} or !$certs{$name}{valid_soon}) {
            
	    # Identify issues that have been already handled
	    # NOWARN: in the notes or something that smells like a bugzilla bug id
	    if ( $certs{$name}{note} =~ /NOWARN:/ or $certs{$name}{note} =~ /id=\d+/ ) {
	      $status = "acknowledged";
	    }
            elsif ( !$certs{$name}{valid_now} ) {
                $status = "expired";
            }          
	    elsif ( !$certs{$name}{valid_soon} ) {
                $status = "expiring";
            }

            print " * [$status] $name Expires on $certs{$name}{not_after}\n";
        }
	
	
	$certs{$name}{status} = $status;
	
    }
    
    return \%certs;
}

sub check_pools {
    my $zxtm = shift;

    print "** Checking pools\n";

    my $pools = $zxtm->call("/config/active/pools");

    my %pools;
    foreach my $pool (@$pools) {
        my $name = $pool->{name};

        $pools{$name}{info} = $zxtm->call("/config/active/pools/$name");
        $pools{$name}{note} = URI::Escape::uri_unescape(
            $pools{$name}{info}{properties}{basic}{note} );
        $pools{$name}{nodes} = {};

        my $node_count =
          @{ $pools{$name}{info}{properties}{basic}{nodes_table} };
        my $interesting;

        foreach
          my $node ( @{ $pools{$name}{info}{properties}{basic}{nodes_table} } )
        {
            my $state = $node->{state} || '*no-state*';
            $interesting++ if $state ne 'active';
        }

        if ($interesting) {
	    $pools{$name}{interesting} = 1;
            print " Pool $name ($node_count nodes):\n";
            print "  * Note: $pools{$name}{note}\n" if $pools{$name}{note};

            foreach my $node (
                @{ $pools{$name}{info}{properties}{basic}{nodes_table} } )
            {
                my $name = $node->{node};

                if ( $name =~ /(\d+\.\d+\.\d+\.\d+):(\d+)/ ) {
                    my $port = $2;
                    my $ip   = $1;

                    use Socket;
                    my $fqdn = gethostbyaddr( inet_aton($ip), AF_INET );
                    if ($fqdn) {
                        $name = "$fqdn($ip):$port";
                    }

                }

                my $state = $node->{state} || '*no-state*';
                print "  + [$state] $name\n";
            }

        }
    }
    
    return \%pools;
}

my %pretty_names = (
    hourly_peak_bytes_in        => "Hourly Peak Bytes In",
    hourly_peak_bytes_out       => "Hourly Peak Bytes Out",
    hourly_peak_requests        => "Hourly Peak Requests",
    hourly_peak_ssl_connections => "Hourly Peak SSL Connections",
    sys_cpu_busy                => "CPU Busy",
    sys_cpu_idle                => "CPU Idle",
    sys_cpu_system_busy         => "CPU Syatem Busy",
    sys_cpu_user_busy           => "CPU User Busy",
    sys_mem_buffered            => "Memory Buffered",
    sys_mem_free                => "Memory Free",
    sys_mem_in_use              => "Memory Used",
    sys_mem_swap_total          => "Swap Total",
    sys_mem_swapped             => "Swap Used",
    sys_mem_total               => "Memory Total",
);

sub output_stat {
    my ( $stat, $stat_value ) = @_;

    my $val;

    if ( $stat =~ /peak/ ) {
        $val = format_bytes($stat_value);

        if ( $stat =~ /_per_second/ ) {
            $stat =~ s/_per_second//;
            $val .= "/s";
        }
    }

    if ( $stat =~ /^sys_cpu/ ) {
        $val = $stat_value;

        if ( $stat =~ /_percent$/ ) {
            $stat =~ s/_percent$//;
            $val .= " %";
        }
    }

    if ( $stat =~ /^sys_mem/ ) {
        $val = format_bytes( $stat_value * 1024 * 1024 );
    }

    if ( $stat =~ /^ssl_cipher_(de|en)crypts/ ) {
        $val = $stat_value;
    }

    if ($val) {
        my $pretty = $pretty_names{$stat} || $stat;
        print "    - $pretty: $val\n";
    }
}



__END__
